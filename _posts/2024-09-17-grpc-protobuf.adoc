:showtitle:
:page-navtitle: Au-delà de REST : Découvrir les avantages de gRPC et Protobuf
:page-excerpt: Découvrez comment gRPC et Protobuf peuvent révolutionner votre façon de concevoir et de développer des API. Apprenez à tirer parti du typage fort, de la sérialisation efficace et du streaming bidirectionnel pour créer des applications réactives et haute performance.
:layout: post
:author: kostiantynkompaniiets
:page-tags: [Java, Quarkus, REST, API, gRPC, Protobuf]
:page-vignette: grpc-protobuf.png
:page-liquid:
:page-categories: software

= Au-delà de REST : Découvrir les avantages de gRPC et Protobuf

Il semble très difficile de trouver un développeur qui n'ait jamais entendu parler de REST. Ce n'est pas surprenant : ce style (ou plus précisément, cette approche de la construction de connexions réseau et de protocoles) est depuis de nombreuses années la norme de référence dans le développement logiciel. Sa simplicité d'utilisation intuitive et son abstraction par rapport aux langages de programmation spécifiques font de REST (couplé à JSON) le choix idéal pour tout développeur confronté à des connexions réseau (et, selon mon humble avis, cela concerne la grande majorité des développeurs).

Bien sûr, REST n'est pas le seul outil pour transférer des données. Avec l'évolution dynamique du monde de la programmation et de l'architecture logicielle, de nouvelles alternatives ont vu le jour pour répondre aux besoins actuels des développeurs. GraphQL, WebSockets, MQTT, Event-Driven Architecture — ces outils et paradigmes sont également largement utilisés.

Cependant, dans cet article, j’aimerais attirer votre attention sur une autre approche intéressante pour créer des connexions réseau entre les services, à savoir gRPC et son partenaire inséparable - Protocol Buffers, ou simplement Protobuf. À ce stade, beaucoup d'entre vous se demanderont : pourquoi j'aurais besoin de quelque chose dont je n'ai probablement jamais entendu parler auparavant, et qui peut être facilement résolu en utilisant l'approche REST ? C’est à cette question que nous allons essayer de répondre ci-dessous.

== Qu'est-ce que gRPC ?

Selon le site Web officiel, gRPC est un framework RPC moderne, performant et open-source, capable de fonctionner dans n’importe quel environnement. Le concept de RPC (Remote Procedure Call) n’est pas nouveau dans le domaine de la programmation. Ce protocole, qui permet à un programme sur un service/serveur d’appeler des fonctions sur un autre service/serveur, existe depuis le début des années 80. En 2016, Google a lancé un framework basé sur ce protocole et l’a nommé gRPC (comme vous l’aurez deviné, le “g” dans le nom du framework représente “Google”).

Tout d'abord, il faut noter que gRPC est basé sur HTTP/2, la version du protocole de transfert de données HTTP, successeur de HTTP/1.1, qui a été adoptée comme standard un an avant le lancement du framework. Il utilise Protocol Buffers (Protobuf) comme langage de description d’interfaces. C’est ce point que je propose d'examiner à l'étape suivante.

== Protocol Buffers : concept et syntaxe

Les Protocol Buffers (ou simplement Protobuf) sont un mécanisme de sérialisation de données et un langage de description d'interfaces, développés par Google pour sérialiser des données structurées. Ils sont indépendants des langages et des plateformes, ce qui permet de transmettre et de stocker des données de manière efficace. Protobuf définit la structure de vos données et génère automatiquement du code pour la sérialisation et la désérialisation selon le langage de programmation choisi. Les données de ce format sont sérialisées et transmises sous forme binaire, ce qui garantit une vitesse de transport supplémentaire. Protobuf prend en charge la génération de code pour des langages de programmation tels que C++, C#, Dart, Go, Java, Kotlin, Objective-C, Python et Ruby (la dernière version, proto3, fonctionne également avec PHP) grâce au compilateur Protoc. De plus, une intégration avec JavaScript est en cours (bien qu’il existe déjà des implémentations non officielles pour JavaScript, TypeScript et Node.js).

Examinons de plus près la syntaxe de Protobuf :

[source,protobuf]
----
syntax = "proto3";

package com.test.user;

message User {
 int32 id = 1;
 string name = 2;
 string email = 3;
 Role role = 4;
 bool is_blocked = 5;
}

enum Role {
 ROLE_UNSPECIFIED = 0;
 USER = 1;
 SUPER_USER = 2;
 ADMIN = 3;
}
----

Donc, ce qu’on voit :

* La première ligne de code indique la version de syntaxe Protobuf qui sera utilisée (proto3 est la version actuelle, la version proto2 est utilisée par défaut) ;
* Ensuite, il y a un attribut facultatif : la définition du package (similaire aux packages en Java) pour éviter les collisions de noms dans les modèles ;
* Après cela, on peut voir le modèle de données, qui est indiqué par le mot clé "message" et bien sûr par le nom du modèle (pour les développeurs Java ou TypeScript, cela correspond à une classe ou à un DTO) ;
* L'étape suivante consiste à définir les champs nécessaires et leurs types (en effet, Protobuf est un langage typé, ce qui est un grand avantage par rapport à JSON). Comme vous pouvez le constater, pour ajouter un champ, vous devez spécifier son type, son nom et son numéro d'ordre. Il est important de noter que la numérotation des champs commence à 1 (la valeur avec le numéro d'ordre 0 n'est disponible que pour les énumérations et correspond à la valeur par défaut), et doit également être unique dans le cadre d’un modèle (message) ;
* Il convient également de mentionner la création d'énumérations (pour les développeurs Java ou TypeScript, cela correspond à un enum). Une bonne pratique dans Protobuf est de créer une valeur par défaut avec le numéro d’ordre 0.

Ce sont essentiellement tous les détails de la syntaxe Protobuf. Ensuite, je propose d’examiner la création de services gRPC.

== Syntaxe d'un service gRPC

Pour utiliser gRPC, il est d’abord nécessaire de créer un service et les méthodes requises (évidemment, à l'aide de Protobuf). Voyons tout de suite un exemple de ce type de service :

[source,protobuf]
----
syntax = "proto3";

package com.test.service;

import "user.proto";

service UserService {
 rpc GetUserById (UserId) returns (com.test.user.User);
 rpc GetAllUsers () returns (UserList);
}

message UserId {
 int32 id = 1;
}

message UserList {
 repeated com.test.user.User users = 1;
}
----

Comme dans l'exemple précédent, on commence par la définition de la version de la syntaxe et du package, puis on voit une nouveauté : nous importons le modèle d’utilisateur créé précédemment à partir d’un autre fichier à l’aide du mot-clé “import” pour utiliser le modèle correspondant dans le fichier actuel.

L’étape suivante consiste à créer un service RPC. Pour cela, il suffit de créer une nouvelle entité avec le nom souhaité (UserService) et de la marquer avec le mot-clé “service”. Ensuite, la création des méthodes commence : la méthode est définie à l’aide du mot-clé “rpc”, suivie du nom de la méthode (GetUserById), des types de ses paramètres (UserId) ainsi que du type de valeur de retour. Visuellement, cela ressemble beaucoup à une interface en Java, n’est-ce pas ?

Enfin, j’aimerais mentionner un point intéressant et très utile : le mot-clé “repeated”, utilisé pour créer des collections (dans notre exemple, il s'agit d'une collection d’utilisateurs dans le modèle UserList).

Voilà donc tout ce qu’il faut savoir pour créer un service gRPC. Ensuite, je propose de découvrir les avantages de cette approche et de la comparer au standard largement reconnu qu’est REST.

== gRPC vs REST

Maintenant que nous avons compris ce qu’est gRPC, nous pouvons passer à ses points forts et faibles, et déterminer quand l’utiliser ou éviter son utilisation.

=== Avantages et inconvénients de gRPC

Les principaux avantages de gRPC sont :

* Haute performance : gRPC utilise HTTP/2, ce qui permet de créer plusieurs requêtes sur la base d'une même connexion, entraînant une augmentation significative de la vitesse de transfert d'informations.
* Transmission bidirectionnelle : gRPC prend en charge la transmission bidirectionnelle en flux (grâce à HTTP/2), ce qui permet d'utiliser des schémas de communication plus complexes et d'échanger des données en temps réel.
* Indépendance linguistique : gRPC et Protobuf prennent en charge la compilation dans un large éventail de langages de programmation. Cela permet de créer des services RPC dans différentes langues tout en assurant une communication fluide entre eux.
* Typage strict : L'utilisation de fichiers proto assure une définition claire de la structure des données, ce qui aide à prévenir les erreurs et à améliorer la qualité du code.
* Taille des messages réduite : L'utilisation d'un format binaire permet de transmettre des données de manière plus compacte, ce qui réduit la charge sur le réseau et rend le transfert de données plus efficace.

Cela semble plutôt bien, n'est-ce pas ? Cependant, ce framework a aussi ses inconvénients (il n'y a pas de rose sans épines), à savoir :

* Implémentation plus complexe : L'utilisation de gRPC et de Protobuf nécessitera plus de temps et d'efforts à maîtriser que l'utilisation d'un API REST classique.
* Écosystème limité et support dans les navigateurs : L'écosystème d'outils et de bibliothèques prenant en charge gRPC peut être plus restreint que pour les API REST (par exemple, Swagger, frameworks de test, etc.). De plus, gRPC n'est pas pris en charge par les navigateurs sans outils ou serveurs proxy supplémentaires.
* Difficulté d'analyse des données transmises : Le format binaire des données peut compliquer le processus de débogage et d'analyse des messages.

=== Domaines d'utilisation de gRPC

Compte tenu de tous ces points forts et faibles, nous pouvons déterminer quand il est pertinent d’utiliser gRPC et quand il vaut mieux l’éviter.

Ainsi, les cas d'utilisation les plus évidents de gRPC sont :

* Architecture microservices : gRPC est idéal pour la communication entre les microservices grâce à sa haute performance et à sa rapidité de transfert de données.
* Applications en temps réel : gRPC peut être utilisé pour les applications nécessitant une faible latence et nécessitant des mises à jour en temps réel, telles que les chats, les résultats sportifs ou les plateformes de trading financier, ainsi que d'autres services qui bénéficient de la transmission bidirectionnelle en flux de données.
* Interopérabilité entre langages : gRPC peut être efficace pour construire des systèmes distribués composés de nombreux composants interagissant écrits dans différents langages de programmation.
* Applications mobiles et IoT : Le format binaire compact de Protobuf est particulièrement utile pour les applications mobiles et IoT, où la bande passante et les performances sont des enjeux critiques.

Dans les cas suivants, l'utilisation de gRPC peut être problématique ou exiger trop d’efforts de configuration :

* Applications Web et services fonctionnant principalement via un navigateur Web : gRPC n'est pas entièrement pris en charge par les navigateurs modernes qui utilisent généralement HTTP/1.1 au lieu de HTTP/2 (sur lequel gRPC est basé). Par conséquent, pour un fonctionnement complet, vous aurez besoin d'outils ou de serveurs proxy supplémentaires, ce qui est plus coûteux en termes d'infrastructure et de ressources d'équipe.
* Écriture de bibliothèques et d'API publiques : Si votre API doit être ouverte et accessible à un large public ou être intégrée à d'autres systèmes, REST avec JSON est un meilleur choix.
* Petits projets ou projets peu exigeants : Si votre projet est petit ou n'a pas d'exigences strictes en matière de performances, l'utilisation de gRPC peut être trop complexe. Pour les petites équipes ou les projets sans exigences intensives en matière de performances et d'évolutivité, une API REST sera plus simple à mettre en place et à maintenir.
* Transmission de gros volumes de données sur le réseau : gRPC transfère les données dans un format binaire et peut utiliser la mise en cache en cours de processus. La performance de ce protocole peut être inférieure lors du transfert continu de grandes quantités de données sur le réseau (bien que, à mon avis, ce ne soit pas la meilleure idée, quel que soit le protocole). En revanche, il convient de noter que la taille maximale d'un fichier proto pris en charge par toutes les implémentations, sous forme sérialisée, doit être inférieure à 2 Go (donc de grandes quantités de données peuvent toujours être essayées de transmettre).

=== Comparaison entre gRPC et REST

Comparons maintenant gRPC et REST en nous basant sur tout ce qui a été mentionné ci-dessus :

[width="100%",cols="27%,37%,36%",options="header",]
|===
|*Paramètre* |*gRPC* |*REST*
|Protocole de transport |HTTP/2 |HTTP/1.1
|Format de données |Protocol Buffers (format binaire) |JSON (format texte)
|Performance |Plus élevée (latence inférieure, sérialisation plus rapide) |Plus faible (latence supérieure, sérialisation plus lente)
|Prise en charge des langages |Supporte de nombreux langages grâce à Protobuf et protoc |Supporté dans tous les langages grâce à HTTP et JSON
|Flux |Supporte le flux bidirectionnel |Ne supporte pas le flux de données
|Complexité de configuration |Plus élevée (nécessité de définir des fichiers proto, génération de code) |Plus faible (configuration simple, fonctionne avec HTTP et JSON)
|Prise en charge par les navigateurs web |Limitée (gRPC-Web) |Supportée par tous les navigateurs web
|Utilisation pour les API publiques |Moins utilisé pour les API publiques en raison de sa complexité |Souvent utilisé en raison de sa simplicité et de sa prévalence
|Évolutivité |Élevée, adaptée aux architectures de microservices |Plus adaptée aux API simples
|===

En résumé, nous pouvons dire que gRPC est excellent pour les systèmes exigeant des performances et une vitesse élevées, les architectures de microservices et les applications en temps réel nécessitant un flux bidirectionnel. En revanche, REST reste une solution simple et universelle pour les API publiques et les bibliothèques, les applications web et les projets pour lesquels la simplicité de mise en œuvre et de maintenance est primordiale.

En tenant compte de tout cela, essayons de répondre à la question : dois-je utiliser gRPC ? Si vous travaillez sur un projet sur lequel l'interaction avec l'utilisateur se fait directement via un navigateur ou si vous créez une API publique (y compris pour interagir avec d'autres microservices qui n'ont pas été écrits et maintenus par vous), ma réponse est non. Cependant, si vous travaillez sur un projet où la communication se fait directement entre les services ou nécessite une connexion bidirectionnelle et de hautes performances (et il y en a beaucoup dans le secteur d'entreprise), alors la réponse est plutôt oui — à condition que ce ne soit pas un projet legacy et que vous disposiez du temps nécessaire pour la configuration.

Oui, je suis d'accord, gRPC ne semble pas être une solution miracle et peut être rebutant en raison de sa complexité de configuration potentielle. Cependant, ne fermez pas cet article trop rapidement, j'ai une dernière section pour [line-through]#vous attirer du côté obscur de la force# vous intéresser davantage.

== Solution hybride

Étant donné que gRPC peut être trop complexe à mettre en œuvre et présente des limitations en termes de fonctionnement dans les navigateurs, je souhaiterais proposer une solution hybride : l'utilisation de REST avec Protobuf. Cette option peut sembler étrange (pourquoi changer quelque chose qui fonctionne déjà bien, comme JSON), mais examinons les avantages potentiels de cette solution :

* Transfert de données plus rapide : Comme nous l'avons déjà mentionné, Protobuf est transmis sur le réseau sous forme binaire, et sa sérialisation et désérialisation sont presque instantanées.
* Typage strict : JSON est le format de données le plus populaire, notamment en raison de l'absence de structure de message définie. Cependant, à mon avis, c'est aussi son principal inconvénient. Protobuf permet de résoudre facilement ce problème.
* Possibilité de génération automatique de code pour de nombreux langages de programmation : Oui, JSON est une technologie neutre en termes de langage, mais pour utiliser les données transmises à l'aide de JSON, il faut créer des DTO et des modèles correspondants. C'est ce que votre framework utilisera pour analyser les données reçues. En revanche, Protobuf (à l'aide de protoc) peut créer ces modèles automatiquement.
* Fonctionnement avec les navigateurs Web : Protobuf n’est pas lié à HTTP/2, donc il n’y a aucun problème pour l’utiliser avec des applications web.

Bien sûr, l'ajout de Protobuf à la place de JSON présente également quelques inconvénients, mais ils ne sont pas si significatifs par rapport aux avantages :

* Complexité d'analyse des messages au format binaire : Si vous devez fréquemment analyser des messages sous forme binaire (par exemple, lors du débogage du réseau), vous pourriez rencontrer des difficultés (d'après mon expérience, ce n'est pas l'opération la plus courante).
* Nécessité de configurer la conversion : Pour travailler avec Protobuf et créer des modèles, vous devrez consacrer un peu de temps à apprendre la syntaxe et à configurer la génération de code à l'aide de protoc, mais ces quelques heures vous feront gagner beaucoup de temps à l'avenir.

Pour transmettre Protobuf sur le réseau, il faut spécifier "application/protobuf" ou "application/x-protobuf" comme type de média (MediaType). Par exemple, dans Quarkus, cela se présenterait ainsi :

[source,java]
----
@Produces("application/protobuf")
----

Dans Spring, un peu plus de code est nécessaire, vous devez ajouter un nouveau convertisseur à votre service :


[source,java]
----
@Bean
ProtobufHttpMessageConverter protobufHttpMessageConverter() {
    return new ProtobufHttpMessageConverter();
}
----

Et pour travailler avec JavaScript/TypeScript, il faut modifier le "responseType" de chaque requête HTTP en "arraybuffer" (probablement en utilisant un intercepteur) :


[source,javascript]
----
responseType: "arraybuffer"
----

== Conclusion

gRPC est un protocole réseau assez intéressant et en même temps un peu inhabituel et complexe. Bien sûr, il ne peut en aucun cas remplacer REST, mais il n'est pas conçu pour cela non plus. gRPC est une excellente alternative à l'approche standard et vise principalement à exploiter toute la puissance du standard HTTP/2, ce qui en fait un outil très puissant en termes de performances, de compacité et de flux de données bidirectionnels.

Je voudrais également souligner Protobuf. Cette technologie n'est pas seulement à la base du framework gRPC, mais peut aussi être utilisée indépendamment (y compris dans les projets web), offrant une alternative très intéressante à l'approche standard basée sur JSON.
