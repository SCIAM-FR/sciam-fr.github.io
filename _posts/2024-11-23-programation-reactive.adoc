= La programmation réactive avec Reactor et Spring Web Flux  
:showtitle:
:page-navtitle: La programmation réactive avec Reactor et Spring Web Flux  
:page-excerpt: ce article decrit les notion de la programation non bloquante avec Reactor et spring Web Flux 
:layout: post
:author: khairikhadhraoui
:page-tags: [java, Spring webFlux, reactor, reactive programming, programation non bloquante, ReactiveX, Reactive Streams ]
:page-vignette: programation-reactive.jpg
:page-liquid:
:page-categories: software news

== Introduction :

L'évolution rapide des architectures logicielles vers des modèles distribués (microservices) et cloud-native a révélé les contraintes 
inhérentes à la programmation bloquante traditionnelle. Pour répondre à ces nouveaux défis, la programmation réactive, fondée sur les 
principes du Reactive Manifesto, propose un paradigme plus adapté pour concevoir et développer des applications Java hautement réactives, 
capables de s'adapter aux fluctuations de charge et de garantir une faible latence.

Pour explorer la programmation réactive, il est utile de comprendre les systèmes non réactifs traditionnels et leurs inconvénients, 
en particulier en ce qui concerne l'utilisation des ressources et la gestion des événements. 

Les systèmes non réactifs, aussi appelés systèmes synchrones ou bloquants, sont les approches traditionnelles utilisées dans la 
programmation. Voici quelques caractéristiques clés{nbsp}: 


* Traitement séquentiel : une tâche doit généralement attendre la fin de l'exécution de la tâche précédente avant de commencer, 

* Blocage des ressources : les systèmes non réactifs bloquent souvent des ressources (comme des threads ou des connexions réseau) en attendant des résultats, 

* Gestion des événements complexes : la gestion des événements dans les systèmes non réactifs peut devenir complexe et difficile à maintenir, surtout lorsque le nombre d'événements augmente 

* Latence élevée : en raison de la nature bloquante de ces systèmes, ils peuvent entraîner une latence élevée, surtout dans les applications où la rapidité de réponse est cruciale

* Scalabilité limitée : comme chaque requête ou tâche peut nécessiter son propre thread ou processus, l'augmentation du nombre de requêtes peut rapidement saturer les ressources du système 

Pour surmonter ces limitations, les systèmes réactifs offrent une alternative en se concentrant sur l'asynchronisme, non-bloquant, et l'efficacité dans l'utilisation 
des ressources. Ils permettent de créer des applications qui sont plus réactives, plus résilientes, et plus scalables, en répondant efficacement aux événements et en
 utilisant les ressources de manière optimale. 

== Les principes de la programmation réactive   

Les principes de la programmation réactive sont encapsulés dans le "Manifeste Réactif", qui énonce quatre caractéristiques clés{nbsp}:

* Responsive (Réactif) : les systèmes réactifs répondent rapidement aux utilisateurs pour garantir une expérience fluide et interactive.

* Resilient (Résilient) : les systèmes réactifs restent opérationnels même en cas de défaillance, grâce à des mécanismes de gestion des erreurs et de redondance.

* Elastic (Élastique) : les systèmes réactifs s'adaptent aux variations de la charge de travail en allouant dynamiquement les ressources nécessaires.

* Message-Driven (Basé sur les Messages) : les systèmes réactifs communiquent par la transmission de messages asynchrones, facilitant la connexion et le découplage des composants.

== Les bibliotheques de la programmation réactive sont basés sur deux modèles{nbsp}: 

* ReactiveX : ReactiveX a été conçu pour fournir une API unifiée pour le traitement de collections asynchrones, en s'inspirant des méthodes 
des collections synchrones (comme map, filter, reduce). Il est souvent utilisé pour gérer des événements utilisateur, des requêtes 
réseau, et d'autres opérations asynchrones dans des applications interactives. Ces implémentations connues sont : RxJava et RxJs. 

* Reactive Streams : Reactive Streams a été créé pour résoudre des problèmes spécifiques de backpressure dans les systèmes de traitement
 de données asynchrones, en définissant un ensemble minimal d'interfaces pour garantir une gestion cohérente et efficace des flux de données
  entre différentes bibliothèques réactives dans l'écosystème JVM. Les implémentations connues sont Akka, Reactor, Vert.x et RxJAVA2.

Dans cet article, on va s'intéresser à Reactor qui est une implémentation de Reactive streams. 

Les objectifs principaux de Reactive Streams sont {nbsp}: 

* Asynchronisme : gérer les flux de données de manière non bloquante et asynchrone. 

* Backpressure :S'assurer du nombre d'éléments que le consommateur peut recevoir, évitant ainsi les surcharges. 

* Interopérabilité : Fournir une interface standard pour que différentes bibliothèques réactives puissent fonctionner ensemble. 

Les principales interfaces de Reactive Streams sont{nbsp}: 

* `Publisher<T>` : représente une source qui peut émettre une séquence de valeurs asynchrones. Les éditeurs appellent la méthode `subscribe()` pour permettre aux abonnés de recevoir les éléments. 

* `Subscriber<T>` : représente un consommateur de données. Il reçoit les éléments émis par le producteur 'Publisher' via la méthode : onSubscribe(). 

* `Subscription` : gère le lien entre un 'Publisher' et un 'Subscriber'. Elle permet de demander des éléments (request(long n)) ou d'annuler la souscription (cancel()). 

* `Processor<T, R>` : combine les fonctionnalités d'un 'Publisher' et d'un 'Subscriber'. Un 'Processor' reçoit des éléments, les traite, et les renvoie sous forme d'un autre flux. 

== Le Project Reactor : 

Reactor est une bibliothèque réactive pour Java développée par Pivotal (maintenant VMware) et intégrée dans l'écosystème Spring. Elle fournit une implémentation de Reactive Streams et permet de 
construire des applications non bloquantes, asynchrones, et scalables. Reactor est au cœur de Spring WebFlux, le module réactif Web de Spring Framework. 

Les principales abstractions fournies par Reactor sont {nbsp}: 

 * 'Mono<T>' : représente un flux réactif qui produit au maximum une seule valeur. 

 * 'Flux<T>' : représente un flux réactif qui peut émettre zéro, une ou plusieurs valeurs, voire un flux infini. 

Ces deux types sont les composants de base utilisés pour modéliser des flux de données asynchrones en Java avec Reactor. 

En pratique un 'Flux' peut être sérialisé sous plusieur formes{nbsp}: 

* Json Array 

* Text Event Stream 

* Flux de json stream

== Spring Web Flux avec Reactor  

Spring Web Flux fait partie de projet Spring 5 : c'est un module Spring basé sur une API HTTP exposée à la source sur reactive Streams dans lequel 
on continue à utiliser les mêmes annotations pour les contrôleurs Spring MVC (`@Controller`, `@RequestMapping`, etc). Cependant au lieu d'utiliser 
des types de retour `List<T>`, `T` ou `void`, on utilise `Flux<T>` ou `Mono<T>`.  

=== Les composants de Spring WebFlux {nbsp}:

* Les contrôleurs réactifs : comme dans Spring MVC, mais avec des types réactifs `Mono` et `Flux`. 

* `WebClient` : un client HTTP non-bloquant qui remplace `RestTemplate` pour les appels externes réactifs. 

* Router Function : une approche fonctionnelle pour définir des routes HTTP. 

==== Les avantages{nbsp}:

* Scalabilité : la nature non-bloquante permet de gérer un grand nombre de connexions simultanées avec moins de threads. 

* Performance : adapté pour les applications nécessitant une faible latence et une haute performance. 

* Flexibilité : peut être utilisé pour des microservices, des applications Web, ou même des applications fonctionnant avec d'autres paradigmes réactifs comme RxJava. 

==== Les inconvénients :

Bien que la programmation réactive soit un outil puissant pour de nombreuses applications modernes, elle présente également des inconvénients.

* Débogage et test complexes : Les applications réactives introduisent des comportements asynchrones difficiles à tracer, rendant le débogage et la compréhension des erreurs plus compliqués. De même, les tests nécessitent souvent des outils spécialisés pour simuler les flux asynchrones.

* Code plus difficile à lire et maintenir : En raison de la composition des flux et des chaînes d'opérateurs, le code réactif peut devenir difficile à comprendre, en particulier pour ceux qui n’ont pas l’habitude de travailler avec ce paradigme.

* Coût d'intégration dans les projets existants : Migrer une application traditionnelle vers une approche réactive peut être coûteux et complexe. Il peut être nécessaire de refactoriser une grande partie du code et d’adapter les couches d’infrastructure.

* Pas toujours adapté : Toutes les applications n'ont pas besoin des avantages de la programmation réactive, comme la haute disponibilité ou l'évolutivité massive. Pour des applications simples ou à faible trafic, l'approche réactive peut introduire une complexité inutile.

== La configuration d'un projet Spring WebFlux 

=== La configuration Maven :  

Pour configurer un projet Maven avec Spring WebFlux et Reactor, il faut ajouter les dépendances appropriées dans le fichier pom.xml :
[source,plain]
----
 <dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
<!-- https://mvnrepository.com/artifact/org.projectreactor/reactor-spring -->
<dependency>
    <groupId>org.projectreactor</groupId>
    <artifactId>reactor-spring</artifactId>
    <version>1.0.1.RELEASE</version>
</dependency>
----

=== La création d'un contrôleur réactif : 

Le contrôleur contient deux méthodes :

*La première méthode : retourne un Mono créé à partir d'une valeur unique fournie en paramètre.

*La deuxième méthode fournit un flux (Flux) représentant une séquence d'entiers allant de 1 à 10, avec un délai de 100 millisecondes entre chaque élément émis.

Si un client appelle l'API /numbers, il recevra chaque nombre (de 1 à 10) avec un intervalle de 100 millisecondes entre eux.
 
[source,java]
----
@RestController 

 public class ReactiveController { 
 	  @GetMapping("/hello")  
        public Mono<String> sayHello() {   
          return Mono.just("Hello, WebFlux!"); 
    }  

    @GetMapping("/numbers")  
      public Flux<Integer> getNumbers() {  
        return Flux.range(1, 10).delayElements(Duration.ofMillis(100));  
    }  
} 
----

=== Un exemple d'utilisation de WebClient : 

[source,java]
----
public class WebClientExample { 
  private final WebClient webClient =WebClient.create("http://example.com"); 
    public Mono<String> fetchData() { 
 	    return webClient.get() .uri("/api/data") .retrieve()  
          .bodyToMono(String.class);    
  } 
 } 
----

=== La gestion du backpressure 

Le backpressure est une composante essentielle dans les systèmes réactifs pour gérer le flux de données entre les producteurs et les consommateurs. 
Avec Reactor, vous pouvez contrôler le backpressure via des opérateurs comme `limitRate`. 

Exemple d'utilisation de `limitRate` pour réguler la consommation des données : 

[source,java]
---- 

Flux<Integer> flux = WebClient.create("http://example.com")  
                              .get()  
                                .uri("/api/large-stream")  
                                  .retrieve() .bodyToFlux(Integer.class)  
                                    .limitRate(5); 
                    flux.subscribe(data -> { System.out.println("Received: " + data);}); 

----

= Conclusion 

Spring Reactor propulse le développement d'applications modernes vers de nouveaux sommets en leur conférant réactivité, performance et résilience. En s'alignant 
sur le Reactive Manifesto, cette technologie ouvre la voie à des systèmes distribués agiles et efficaces. Toutefois, son adoption implique une courbe d'apprentissage 
plus prononcée, en particulier pour comprendre les concepts de la programmation réactive.
