= La programmation réactive avec Reactor et Spring Web Flux  
:showtitle:
:page-navtitle: La programmation réactive avec Reactor et Spring Web Flux  
:page-excerpt: ce article decrit les notion de la programation non bloquante avec Reactor et spring Web Flux 
:layout: post
:author: khairikhadhraoui
:page-tags: [java, Spring webFlux, reactor, reactive programming, programation non bloquante, ReactiveX, Reactive Streams ]
:page-vignette: programation-reactive.jpg
:page-liquid:
:page-categories: software news

== Introduction

Pendant longtemps, la programmation Java a été dominée par un modèle synchrone et bloquant. Cependant, l'évolution des architectures 
logicielles, notamment l'émergence des microservices et du cloud computing, a mis en évidence les limites de ce modèle. Pour répondre 
à ces nouveaux défis, un nouveau paradigme a vu le jour : la programmation réactive en s'appuyant sur le Reactive Manifesto, offre une 
solution robuste et performante pour mettre en œuvre des applications réactives en Java.

Pour explorer la programmation réactive, il est utile de comprendre les systèmes non réactifs traditionnels et leurs inconvénients, 
en particulier en ce qui concerne l'utilisation des ressources et la gestion des événements. 

Les systèmes non réactifs, aussi appelés systèmes synchrones ou bloquants, sont les approches traditionnelles utilisées dans la 
programmation. Voici quelques caractéristiques clés{nbsp}: 


* Traitement séquentiel : une tâche doit généralement attendre la fin de l'exécution de la tâche précédente avant de commencer, 

* Blocage des ressources : les systèmes non réactifs bloquent souvent des ressources (comme des threads ou des connexions réseau) en attendant des résultats, 

* Gestion des événements complexes : la gestion des événements dans les systèmes non réactifs peut devenir complexe et difficile à maintenir, surtout lorsque le nombre d'événements augmente 

* Latence élevée : en raison de la nature bloquante de ces systèmes, ils peuvent entraîner une latence élevée, surtout dans les applications où la rapidité de réponse est cruciale

* Scalabilité limitée : comme chaque requête ou tâche peut nécessiter son propre thread ou processus, l'augmentation du nombre de requêtes peut rapidement saturer les ressources du système 

Pour surmonter ces limitations, les systèmes réactifs offrent une alternative en se concentrant sur l'asynchronisme, la non-bloquante, et l'efficacité dans l'utilisation des ressources. Ils permettent de créer des applications qui sont plus réactives, plus résilientes, et plus scalables, en répondant efficacement aux événements et en utilisant les ressources de manière optimale. 

== Les principes de la programmation réactive   

Les principes de la programmation réactive sont encapsulés dans le "Manifeste Réactif", qui énonce quatre caractéristiques clés{nbsp}:

* Responsive (Réactif) : Les systèmes réactifs répondent rapidement aux utilisateurs pour garantir une expérience fluide et interactive. 

* Resilient (Résilient) : Les systèmes réactifs restent opérationnels même en cas de défaillance, grâce à des mécanismes de gestion des erreurs et de redondance. 

* Elastic (Élastique) : Les systèmes réactifs s'adaptent aux variations de la charge de travail en allouant dynamiquement les ressources nécessaires. 

* Message-Driven (Basé sur les Messages) : Les systèmes réactifs communiquent par la transmission de messages asynchrones, facilitant la déconnexion et le découplage des composants. 

== Les bibliotheques de la programmation réactive sont basés sur deux modèles{nbsp}: 

* ReactiveX : ReactiveX a été conçu pour fournir une API unifiée pour le traitement de collections asynchrones, en s'inspirant des méthodes 
des collections synchrones (comme map, filter, reduce). Il est souvent utilisé pour gérer des événements utilisateur, des requêtes 
réseau, et d'autres opérations asynchrones dans des applications interactives. Ces implémentations connues sont : RxJava et RxJs. 

* Reactive Streams: Reactive Streams a été créé pour résoudre des problèmes spécifiques de backpressure dans les systèmes de traitement de données 
asynchrones, en définissant un ensemble minimal d'interfaces pour garantir une gestion cohérente et efficace des flux de données 
entre différentes bibliothèques réactives dans l'écosystème JVM. Ces implementation connues sont Akka Reactor Vertex et RxJAVA2 

Dans notre article, on va s'intéresser à Reactor qui est une implémentation de Reactive streams. 

Les objectifs principaux de Reactive Streams sont {nbsp}: 

* Asynchronisme : gérer les flux de données de manière non bloquante et asynchrone. 

* Backpressure :S'assurer du nombre d'éléments que le consommateur peut recevoir, évitant ainsi les surcharges. 

* Interopérabilité : Fournir une interface standard pour que différentes bibliothèques réactives puissent fonctionner ensemble. 

Les principales interfaces de Reactive Streams sont{nbsp}: 

* `Publisher<T>` : représente une source qui peut émettre une séquence de valeurs asynchrones. Les éditeurs appellent la méthode `subscribe()` pour permettre aux abonnés de recevoir les éléments. 

* Subscriber<T> : Représente un consommateur de données. Il reçoit les éléments émis par un Publisher via quatre méthodes : onSubscribe(), onNext(), onError(), et onComplete(). 

* Subscription : Gère le lien entre un Publisher et un Subscriber. Elle permet de demander des éléments (request(long n)) ou d'annuler la souscription (cancel()). 

* Processor<T, R> : Combine les fonctionnalités d'un Publisher et d'un Subscriber. Un Processor reçoit des éléments, les traite, et les renvoie sous forme d'un autre flux. 

== Project Reactor : 

Reactor est une bibliothèque réactive pour Java développée par Pivotal (maintenant VMware) et intégrée dans l'écosystème Spring. Elle fournit une implémentation de Reactive Streams et permet de construire des applications non bloquantes, asynchrones, et scalables. Reactor est au cœur de Spring WebFlux, le module réactif de Spring Framework. 

Les principales abstractions fournies par Reactor sont {nbsp}: 

 * Mono<T> : Représente un flux réactif qui produit au maximum une seule valeur ou une erreur. 

 * Flux<T> : Représente un flux réactif qui peut émettre zéro, une ou plusieurs valeurs, voire un flux infini. 

Ces deux types sont les composants de base utilisés pour modéliser des flux de données asynchrones en Java avec Reactor. 

En pratique un Flux peut être sérialisé sous plusieur formes  {nbsp}: 

* Json Array : retourne un arrayList normale 

* Text Event Stream : envoie un flux d'objets Json contenue donnés par donne dès qu’ils sont disponible. 

* Flux de json stream : De la même manière entre deux serveurs on peut avoir un flux de  json Stream. 

== Spring Web Flux avec Reactor  

Spring web flux fait partie de projet Spring 5  c'est un module Spring basé sur une api http exposé à la source sur reactive Streams. dans lequel on continue à utiliser les mêmes annotation du contrôleurs Spring MVC (@conttreler, @RequestMapping, etc.) sauf que au lieu d'utiliser des type de retour List<T>, T ou void, on utilise Flux<T> ou Mono<T>.  

=== Composants de Spring WebFlux {nbsp}:

* Contrôleurs Réactifs : Comme dans Spring MVC, mais avec des types réactifs comme Mono et Flux. 

* WebClient : Un client HTTP non-bloquant qui remplace RestTemplate pour les appels externes réactifs. 

* Router Function : Une approche fonctionnelle pour définir des routes HTTP. 

==== Avantages{nbsp}:

* Scalabilité : La nature non-bloquante permet de gérer un grand nombre de connexions simultanées avec moins de threads. 

* Performance : Idéal pour les applications nécessitant une faible latence et une haute performance. 

* Flexibilité : Peut être utilisé pour des microservices, des applications Web, ou même des applications fonctionnant avec d'autres paradigmes réactifs comme RxJava. 

==== Inconvénients :

Bien que la programmation réactive soit un outil puissant pour de nombreuses applications modernes, elle présente également des inconvénients.

* Débogage et test complexes : Les applications réactives introduisent des comportements asynchrones difficiles à tracer, rendant le débogage et la compréhension des erreurs plus compliqués. De même, les tests nécessitent souvent des outils spécialisés pour simuler les flux asynchrones.

* Code plus difficile à lire et maintenir : En raison de la composition des flux et des chaînes d'opérateurs, le code réactif peut devenir difficile à comprendre, en particulier pour ceux qui n’ont pas l’habitude de travailler avec ce paradigme.

* Coût d'intégration dans les projets existants : Migrer une application traditionnelle vers une approche réactive peut être coûteux et complexe. Il peut être nécessaire de refactoriser une grande partie du code et d’adapter les couches d’infrastructure.

* Pas toujours adapté : Toutes les applications n'ont pas besoin des avantages de la programmation réactive, comme la haute disponibilité ou l'évolutivité massive. Pour des applications simples ou à faible trafic, l'approche réactive peut introduire une complexité inutile.

== Configuration d'un projet Spring WebFlux 

=== Configuration Maven :  

Pour configurer un projet Maven avec Spring WebFlux et Reactor, il est essentiel d'ajouter les dépendances appropriées dans le fichier pom.xml. Voici les étapes à suivre pour inclure ces dépendances. 
[source,plain]
----
 <dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
<!-- https://mvnrepository.com/artifact/org.projectreactor/reactor-spring -->
<dependency>
    <groupId>org.projectreactor</groupId>
    <artifactId>reactor-spring</artifactId>
    <version>1.0.1.RELEASE</version>
</dependency>
----

=== Création d'un contrôleur réactif: 

 
[source,java]
----
@RestController 

 public class ReactiveController { 
 	  @GetMapping("/hello")  
        public Mono<String> sayHello() {   
          return Mono.just("Hello, WebFlux!"); 
    }  

    @GetMapping("/numbers")  
      public Flux<Integer> getNumbers() {  
        return Flux.range(1, 10).delayElements(Duration.ofMillis(100));  
    }  
} 
----

=== Exemple d'utilisation de WebClient : 

[source,java]
----
public class WebClientExample { 
  private final WebClient webClient =WebClient.create("http://example.com"); 
    public Mono<String> fetchData() { 
 	    return webClient.get() .uri("/api/data") .retrieve()  
          .bodyToMono(String.class);    
  } 
 } 
----

=== La gestion du backpressure 

Le backpressure est une composante essentielle dans les systèmes réactifs pour gérer le flux de données entre les producteurs et les consommateurs. 
Avec Reactor, vous pouvez contrôler le backpressure via des opérateurs comme `limitRate`. 

Exemple d'utilisation de `limitRate` pour réguler la consommation des données : 

[source,java]
---- 

Flux<Integer> flux = WebClient.create("http://example.com")  
                              .get()  
                                .uri("/api/large-stream")  
                                  .retrieve() .bodyToFlux(Integer.class)  
                                    .limitRate(5); 
                    flux.subscribe(data -> { System.out.println("Received: " + data);}); 

----

= Conclusion 

Spring Reactor propulse le développement d'applications modernes vers de nouveaux sommets en leur conférant réactivité, performance et résilience. En s'alignant 
sur le Reactive Manifesto, cette technologie ouvre la voie à des systèmes distribués agiles et efficaces. Toutefois, son adoption implique une courbe d'apprentissage 
plus prononcée, en particulier pour comprendre les concepts de la programmation réactive. Cependant, pour les projets exigeant une grande performance et une grande 
évolutivité, WebFlux est une solution robuste et adaptée aux besoins actuels.
