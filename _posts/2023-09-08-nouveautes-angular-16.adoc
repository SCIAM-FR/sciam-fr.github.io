:showtitle:
:page-navtitle: Les nouveautés de Angular 16
:page-excerpt: Cet article provoque les nouveautés de Angular 16 et la nouvelle révolution façon de développer avec Angular.
:layout: post
:author: khaoulamrabet
:page-tags: [Angular, Angular16, Signal, Hydratation, Router, Sous-RFC, Rxjs]
:page-vignette: java-20.png
:page-liquid:
 
= Nouveautés de Angular16

Dans ce article on va provoquer les principales nouveautés d’Angular 16 .
Avec cette version la façon d’écriture de code sera changé, une grande révolution nous attend :D .

== Hydratation 

*SSR* (Server-side rending)
Lors de lancement de l’application côté navigateur, Angular réutilise les informations disponibles dans le code HTML généré par le serveur. 


image::{{'/images/khaoulamrabet/code-hydratation.png' | relative_url}}[image,width=50%,align="center"]

A chaque changement de comportement, le serveur va enregistrer une copie de la version ce qui permet d'améliorer la rapidité de lancement de nos applications, le temps de chargement va être réduit. 
Cette technologie est faite par Angular Universal qui permet à Angular de restituer une application sur le serveur, générant un contenu HTML statique.

Avec Angular, la restitution de code HTML de tous les nœuds de zéro à chaque changement fait.
Alors que Angular 16 recherche les nœuds DOM existants tout en créant des structures de données internes et attache des écouteurs d'événements à ces nœuds. 
Donc le changement sera fait que sur le nœud cible. Avec cette amélioration on gagne plus dans le temps de chargement de l’application.
Pour commencer avec l’hydratation c’est juste d’ajouter ce code à *main.ts* 


image::{{'/images/khaoulamrabet/code-hydratation.png' | relative_url}}[image,width=50%,align="center"]


== ESBUILD

Dans cette nouvelle version d'Angular, *le système de construction* est basé sur esbuild pour les développeurs

image::{{'/images/khaoulamrabet/es-build.png' | relative_url}}[image,width=50%,align="center"]

EsBuild améliore le temps d'exécution de l'application en produition froid. Il utilse vite comme capot. Changer la propriété Build dans *angular.json*:

[source,javascript]
----
  "architecte" :{
       "build" : "@angular-devkit/build-angular:browser- esbuild" } 

----

== Signals Angular 

La grande nouveauté d’Angular 16 est le *Signal* Angular. Le concept de signal dans Angular est une fonctionnalité introduite dans la version 16 de la bibliothèque *@angular/core* . 

Il permet de définir des valeurs réactives et d'exprimer des dépendances entre ces valeurs.
Ce schéma détaille l’interface *WritableSignal* et ses méthodes pour la manipulation de Signal.

image::{{'/images/khaoulamrabet/es-build.png' | relative_url}}[image,width=50%,align="center"]

=== Exemple Autocomplete Général utilisant Signal: 

Le composant autocomplète partagé dans toute l’application *Shared* qui permet d’afficher une liste de donnée envoyé par le composant parent avec la possibilité d’affiner la recherche en entrent le nom de donnée dans l’input. 

==== Partie TS: auto-complete.component.ts

[source,javascript]
----
import {Component, Input, OnChanges, signal}from '@angular/core';
import { FormControl} from '@angular/forms';
import { ListDataType} from'@app/shared/interfaces/ListDataType.inteface';

@Component({
  selector: 'sciam-auto-complete',
  templateUrl:'./auto-complete.component.html',
  styleUrls: ['./auto-complete.component.scss']
})
export class AutoCompleteComponent implements OnChanges {

  @Input({required:true}) listData?:ListDataType;
  myControl= new FormControl('');
  filteredOptions= signal<never[]|undefined>([]);
  constructor() {
    this.change();
  }
  ngOnChanges() {
    this.filteredOptions.set(this.listData?.list);
  }
  change() {
    const list = this._filter(this.myControl.value);
    this.filteredOptions.set(list);
  }
  private _filter(value?:string | null) {
    const filterValue =value?.toLowerCase();

    return this.listData?.list?.filter((option: string)  => option?.toLowerCase().includes(<string>filterValue));
  }
}
----

* *FilteredOptions* : le signal qui contient les données de la liste à afficher 
Dans la fonction *change()* implementé dans le code au-dessus : on filtre les données et affecter les données au Signal avec la méthode *set()*.

* ListDataType: c'est un type définit dans l'application.

==== Partie Html : auto-complete.componont.html 

[source,html]
----
  <input type="text" 
       placeholder="{{listData?.label}}" 
       matInput (click)="change()" 
       [formControl]="myControl"
       [matAutocomplete]="auto">
<mat-autocomplete autoActiveFirstOption #auto="matAutocomplete">   
   <mat-option *ngFor="let option of filteredOptions()" [value]="option">
      {{option}}
   </mat-option>
</mat-autocomplete>

----

* Avec Directive *ngFor* on pourra parcourir le signal de façon asynchrone.

