:showtitle:
:page-navtitle: Les nouveautés de Angular 16
:page-excerpt: Cet article provoque les nouveautés de Angular 16 et la nouvelle révolution façon de développer avec Angular.
:layout: post
:author: khaoulamrabet
:page-tags: [Angular, Angular16, Signal, Hydratation, Router, Sous-RFC, Rxjs]
:page-vignette: angular-16.png
:page-liquid:
 
= Nouveautés de Angular16


Angular est un framework Client fondé par Google en 2009 et depuis la version Angular 2, le framework est devenu bien structuré, solide et qui permet de créer des aplications performantes.

L'équipe Angular travaille chaque année sur une nouvelle version pour améliorer la performance de framework et là, la version 16 est sortie avec des nouveautés principalement sur les améliorations de la réactivité et du rendu côté serveur d'Angular.

Dans cet article, on va détailler les principales nouveautés de la version 16 d'Angular.

== Hydratation 
*SSR* (Server-side rending)

L'hydratation est le processus qui restaure l'application rendue côté serveur sur le client. Cela inclut des éléments tels que la réutilisation des structures DOM rendues par le serveur, la conservation de l'état de l'application, le transfert des données d'application déjà récupérées par le serveur et d'autres processus.

Lors de lancement de l’application côté navigateur, Angular réutilise les informations disponibles dans le code HTML généré par le serveur. 

image::khaoulamrabet/hydratation.png[image,width=50%,align="center"]

À chaque changement de comportement, le serveur va enregistrer une copie de la version ce qui permet d'améliorer la rapidité de lancement de nos applications, le temps de chargement va être réduit.
Cette technologie est faite par Angular Universal qui permet à Angular de restituer une application sur le serveur, générant un contenu HTML statique.

Avec Angular, la restitution de code HTML de tous les nœuds de zéro à chaque changement fait.

Alors qu'Angular 16 recherche les nœuds DOM existants tout en créant des structures de données internes et attache des écouteurs d'événements à ces nœuds.
Donc le changement ne sera fait que sur le nœud cible. Avec cette amélioration, on gagne plus dans le temps de chargement de l’application.
Pour commencer avec l’hydratation, c’est juste d’ajouter *provideClientHydration* dans le provider de *App.module.ts* .

[source, typescript]
----
import {provideClientHydration} from '@angular/platform-browser';
import {NgModule} from '@angular/core';

@NgModule({
  declarations: [RootCmp],
  exports: [RootCmp],
  bootstrap: [RootCmp],
  providers: [provideClientHydration()],
})
export class AppModule {}
----

== ESBUILD

Dans cette nouvelle version d'Angular, *le système de construction* est basé sur esbuild pour les développeurs.

image::khaoulamrabet/es-build.png[image,width=50%,align="center"]

EsBuild améliore le temps d'exécution de l'application en produition froid. Il utilse vite comme capot. Changer la propriété Build dans *angular.json*:

[source,typescript]
----
  "architecte" :{
       "build" : "@angular-devkit/build-angular:browser- esbuild" } 

----

== Signals Angular 

La grande nouveauté d’Angular 16 est le *Signal* Angular. Le concept de signal dans Angular est une fonctionnalité introduite dans la version 16 de la bibliothèque *@angular/core* . 

Il permet de définir des valeurs réactives et d'exprimer des dépendances entre ces valeurs.
Ce schéma détaille l’interface *WritableSignal* et ses méthodes pour la manipulation de Signal.

image::khaoulamrabet/signal.png[image,width=50%,align="center"]

=== Exemple Autocomplete Général utilisant Signal: 

Le composant autocomplète partagé dans toute l’application *Shared* qui permet d’afficher une liste de donnée envoyé par le composant parent avec la possibilité d’affiner la recherche en entrent le nom de donnée dans l’input. 

==== Partie TS: auto-complete.component.ts

[source,typescript]
----
import {Component, Input, OnChanges, signal}from '@angular/core';
import { FormControl} from '@angular/forms';
import { ListDataType} from'@app/shared/interfaces/ListDataType.inteface';

@Component({
  selector: 'sciam-auto-complete',
  templateUrl:'./auto-complete.component.html',
  styleUrls: ['./auto-complete.component.scss']
})
export class AutoCompleteComponent implements OnChanges {

  @Input({required:true}) listData?:ListDataType;
  myControl= new FormControl('');
  filteredOptions= signal<never[]|undefined>([]);
  constructor() {
    this.change();
  }
  ngOnChanges() {
    this.filteredOptions.set(this.listData?.list);
  }
  change() {
    const list = this._filter(this.myControl.value);
    this.filteredOptions.set(list);
  }
  private _filter(value?:string | null) {
    const filterValue =value?.toLowerCase();

    return this.listData?.list?.filter((option: string)  => option?.toLowerCase().includes(<string>filterValue));
  }
}
----

* *FilteredOptions* : le signal qui contient les données de la liste à afficher 
Dans la fonction *change()* implementé dans le code au-dessus : on filtre les données et affecter les données au Signal avec la méthode *set()*.

* ListDataType: c'est un type définit dans l'application.

==== Partie Html : auto-complete.componont.html 

[source,html]
----
  <input type="text" 
       placeholder="{{listData?.label}}" 
       matInput (click)="change()" 
       [formControl]="myControl"
       [matAutocomplete]="auto">
<mat-autocomplete autoActiveFirstOption #auto="matAutocomplete">   
   <mat-option *ngFor="let option of filteredOptions()" [value]="option">
      {{option}}
   </mat-option>
</mat-autocomplete>

----

* Avec Directive *ngFor* on pourra parcourir le signal de façon asynchrone.

== toObservable et toSignal 

*La sous-RFC 4* c'est une approche présente deux API innovantes, toObservable et toSignal, conversation entre Observables et Signals. Vous pouvez les trouver dans *@angular/core/rxjs-interop*.

* L'Observable produit par *toObservable* utilise un effect pour envoyer la valeur suivante. Toutes les valeurs émises par l' toObservable Observable sont délivrées de manière asynchrone.

[source,typescript]
----
const count: Observable<number> = toObservable(mySignal);
----

Ici, Count est un observable en prenant la valeur du signal qui va être inspecter par les différents opérateurs de Rxjs (Pipe, subscribe, ...).

* En interne, *toSignal* s'abonne à l'Observable fourni et met à jour le Signal renvoyé chaque fois que l'Observable émet une valeur.

[source,typescript]
----
    Counter$ = of(1000);               
    const counter : Signal < nombre > = toSignal (counter$);

----

Cet cas est pertinent dans le cas de l'observable d'un service par exemple API get qui renvoie un observale et pour inspecter la valeur côté controller en utilisant Signal , on pourra convertir cet dernier en Signal en utilisant *toSignal*.


== Router

Rendre plus simple la récupération des informations (paraméteres, data,..)  de Router sans utilisation de module *ActivatedRouter*.

*Comment?*

* Activez la fonctionnalité *bindToComponentInputs* dans la fonction RouterModule ou provideRouter .
* Ajoutez le décorateur *@Input()* aux propriétés que nous voulons lier aux informations de route.

=== Exemple App routing file :

==== App-routing.module.ts

[source,typescript]
----
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { UserComponent } from './user/user.component';

const routes: Routes = [
  {path:'users/:surname', component: UserComponent, }
];

@NgModule({
  imports: [
    RouterModule.forRoot(routes, {bindToComponentInputs: true})
  ],
  exports: [RouterModule]
})
export class AppRoutingModule { };

----

* Définir un path vers la page user avec un paramétre *surname*
* Activer en ajoutant dans RouterModule object l'option *{bindToComponentInputs: true}*

==== User.component.ts


[source,typescript]
----
@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styleUrls: ['./user.component.scss'],
  
})
export class UserComponent {
   @Input() surname?: string;

    ngOnInit()  {
    console.log('User surname : ', this.surname);
    }
}
----

* Avec Input on récupére directement le paramétre de route.

== Rxjs-interpo

Comprend des utilitaires liés à l'utilisation de la bibliothèque *RxJS* en conjonction avec le système de réactivité basé sur le signal d'Angular. 

*TakeUntilDestroy*:  Opérateur qui complète l'Observable lorsque le contexte appelant (composant, directive, service, etc.) est détruit.

[source,typescript]
----
import { Component, effect, inject, Input, Signal, signal } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { Subject, takeUntil } from 'rxjs';
import { User } from './user.model';
import { UserService } from './user.service';

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
  styleUrls: ['./user.component.scss'],
  
})
export class UserComponent {
  @Input() surname?: string;

  destroyed$: Subject<boolean> = new Subject();
  
  userService = inject(UserService);
  users? : User[] | undefined;
  initialData: Signal<User[] | undefined> = signal([]);
  constructor() {
    
    effect(() => this.users = this.users?.concat(this.userService.list()));
    this.initUsers();
  }
  initUsers() {
   // new version 
    this.userService.getUsers()
    .pipe(takeUntilDestroyed())
    .subscribe(data => {
       this.users = data;
    });
   // old version  
    this.userService.getUsers()
    .pipe(takeUntil(this.destroyed$))
    .subscribe(data => {
       this.users = data;
    });
  }

  ngOnDestroy() {
    this.destroyed$.next(true);
    this.destroyed$.complete();
  }
} 

----

Dans les anciennes versions d'Angular, on utilise *takeUntil* de la bibliothèque  Rxjs, pour détruire un observable. Ici, on est obligé de déclarer *destroyed$* comme un subject et le compléter dans ngOnDestry.

Avec Angular 16, un simple appel de l'opérateur *takeUntilDestroyed* fait le nécessaire.


== Conclusion 

Avec cette nouvelle *version 16*, il y a deux grandes phases d'amélioration, en premier lieu est l'hydratation pour réduire le temps de chargement et en dexiéme, le Signal où angular a ajouté des bibliothèques qui tournent autour de Signal.

J'ai adoré le faite que le code sera plus simple et moins compliqué que les anciennes versions et c'est très remarquable dans les différents exemples de cet article :D. 

Attendons la prochaine Version! 